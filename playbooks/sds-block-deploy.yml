---
# Tasks for Hitachi SDS Block deployment (included from install-hitachi.yml)
# Note: This file contains only tasks, no play header  
# It should be included via ansible.builtin.include_tasks from a parent playbook

# ======================================================================
# Pre-Deployment Cleanup: Remove failed stacks
# ======================================================================

- name: Check for existing failed CloudFormation stack
  tags:
    - 0_cleanup
  amazon.aws.cloudformation_info:
    stack_name: "{{ sds_stack_name | default('hitachi-sds-block-' + ocp_cluster_name) }}"
    region: "{{ ocp_region }}"
    profile: "{{ aws_profile }}"
  register: existing_stack
  ignore_errors: true
  when: deploy_sds_block | default(false) | bool

- name: Set SDS Block stack name early
  tags:
    - 0_cleanup
  ansible.builtin.set_fact:
    sds_stack_name: "hitachi-sds-block-{{ ocp_cluster_name }}"
  when: sds_stack_name is not defined

- name: Clean up failed stack before deployment
  tags:
    - 0_cleanup
  block:
    - name: Delete any failed CloudFormation stack (force)
      amazon.aws.cloudformation:
        stack_name: "{{ sds_stack_name }}"
        state: absent
        region: "{{ ocp_region }}"
        profile: "{{ aws_profile }}"
      register: cleanup_delete
      failed_when: false
      ignore_errors: true
    
    - name: Wait for any previous failed stack to be deleted
      ansible.builtin.pause:
        seconds: 10
      when: cleanup_delete.changed | default(false)
  ignore_errors: true
  when: deploy_sds_block | default(false) | bool

# ======================================================================
# Validate and Auto-Create AWS Resources for SDS Block Deployment
# ======================================================================

- name: Check if aws_profile is configured
  ansible.builtin.assert:
    that:
      - aws_profile is defined and aws_profile | length > 0
    fail_msg: |
      âš ï¸  ERROR: aws_profile is not configured!
      Add to overrides.yml:
        aws_profile: "default"
    success_msg: "âœ… aws_profile is configured: {{ aws_profile }}"

# ======================================================================
# Auto-create or validate EC2 Key Pair
# ======================================================================

- name: Check if EC2 key pair needs to be created or already exists
  block:
    - name: Check if aws_ec2_key_name is placeholder or missing
      ansible.builtin.set_fact:
        needs_ec2_key: "{{ aws_ec2_key_name is undefined or aws_ec2_key_name | length == 0 or aws_ec2_key_name.startswith('your-') }}"
    
    - name: Get list of existing EC2 key pairs
      amazon.aws.ec2_key_info:
        profile: "{{ aws_profile }}"
        region: "{{ ocp_region }}"
      register: existing_keys
      when: not needs_ec2_key
    
    - name: Use first existing key pair if available
      ansible.builtin.set_fact:
        aws_ec2_key_name: "{{ existing_keys.key_pairs[0].key_name }}"
      when: 
        - not needs_ec2_key
        - existing_keys.key_pairs | length > 0
    
    - name: Auto-create new EC2 key pair if needed
      block:
        - name: Generate key pair name based on cluster
          ansible.builtin.set_fact:
            auto_key_name: "{{ ocp_cluster_name }}-sds-key"
        
        - name: Create EC2 key pair
          amazon.aws.ec2_key:
            name: "{{ auto_key_name }}"
            profile: "{{ aws_profile }}"
            region: "{{ ocp_region }}"
            state: present
          register: key_pair_result
        
        - name: Debug key pair result
          ansible.builtin.debug:
            var: key_pair_result
            verbosity: 2
        
        - name: Save private key to file (if returned in creation)
          block:
            - name: Ensure .ssh directory exists
              ansible.builtin.file:
                path: "~/.ssh"
                state: directory
                mode: '0700'
            
            - name: Save the private key material
              ansible.builtin.copy:
                content: "{{ key_pair_result.key.private_key }}"
                dest: "~/.ssh/{{ auto_key_name }}.pem"
                mode: '0600'
          when: 
            - key_pair_result.key is defined
            - key_pair_result.key.private_key is defined
        
        - name: Update aws_ec2_key_name to use auto-created key
          ansible.builtin.set_fact:
            aws_ec2_key_name: "{{ auto_key_name }}"
        
        - name: Print success message
          ansible.builtin.debug:
            msg: |
              âœ… Created EC2 key pair: {{ auto_key_name }}
              ðŸ“ Note: Download the private key from AWS Console (EC2 â†’ Key Pairs)
              ðŸ“ Key pair name: {{ auto_key_name }}
              ðŸ” Keep the private key secure!
      when: needs_ec2_key or (existing_keys.key_pairs | default([]) | length == 0)

# ======================================================================
# Auto-create or validate VPC
# ======================================================================

- name: Check if VPC needs to be found or created
  block:
    - name: Check if aws_vpc_id is placeholder or missing
      ansible.builtin.set_fact:
        needs_vpc: "{{ aws_vpc_id is undefined or aws_vpc_id | length == 0 or aws_vpc_id.startswith('vpc-x') }}"
    
    - name: Get default VPC if VPC needs to be found
      amazon.aws.ec2_vpc_net_info:
        profile: "{{ aws_profile }}"
        region: "{{ ocp_region }}"
        filters:
          isDefault: "true"
      register: default_vpc
      when: needs_vpc
    
    - name: Use default VPC if it exists
      ansible.builtin.set_fact:
        aws_vpc_id: "{{ default_vpc.vpcs[0].vpc_id }}"
      when:
        - needs_vpc
        - default_vpc.vpcs | length > 0
    
    - name: Fail if no VPC found and auto-create not available
      ansible.builtin.fail:
        msg: |
          âš ï¸  ERROR: No default VPC found and aws_vpc_id not configured!
          
          Manually configure aws_vpc_id in overrides.yml with your VPC ID.
          To find your VPC ID, run:
            aws ec2 describe-vpcs --profile {{ aws_profile }} --region {{ ocp_region }} --query 'Vpcs[*].[VpcId,Tags[?Key==`Name`].Value|[0]]' --output table
      when:
        - needs_vpc
        - default_vpc.vpcs | length == 0
    
    - name: Verify VPC exists if already configured
      amazon.aws.ec2_vpc_net_info:
        profile: "{{ aws_profile }}"
        region: "{{ ocp_region }}"
        vpc_ids: "{{ aws_vpc_id }}"
      register: vpc_info
      when: not needs_vpc
      failed_when: vpc_info.vpcs | length == 0

- name: Print AWS resources status
  ansible.builtin.debug:
    msg: |
      âœ… AWS Resources Ready:
        EC2 Key Pair: {{ aws_ec2_key_name }}
        VPC ID: {{ aws_vpc_id }}
        Region: {{ ocp_region }}
        Profile: {{ aws_profile }}

# ======================================================================
# Define local variables for SDS Block deployment
# ======================================================================
- name: Set SDS Block deployment variables
  ansible.builtin.set_fact:
    cf_template_path: "{{ playbook_dir }}/../Temp/Hitachi/sds-block-cf-clean.yaml"
    sds_stack_name: "hitachi-sds-block-{{ ocp_cluster_name }}"
    sds_instance_type: "m5.2xlarge"
    sds_root_volume_size: 100
    sds_data_volume_size: 500
  run_once: true

# ======================================================================
# Phase 1: Pre-deployment Validation
# ======================================================================
- name: Validate CloudFormation template exists
  tags:
    - 1_validation
  ansible.builtin.stat:
    path: "{{ cf_template_path }}"
  register: cf_template_stat
  failed_when: not cf_template_stat.stat.exists

- name: Validate CloudFormation template syntax
  tags:
    - 1_validation
  amazon.aws.cloudformation:
    stack_name: "{{ sds_stack_name }}-validation"
    state: absent
    region: "{{ ocp_region }}"
    profile: "{{ aws_profile }}"
    template_url: "file://{{ cf_template_path }}"
  check_mode: true
  register: cf_validation
  failed_when: false

- name: Check for existing EC2 KeyPair
  tags:
    - 1_validation
  amazon.aws.ec2_key_info:
    profile: "{{ aws_profile }}"
    region: "{{ ocp_region }}"
    names: "{{ aws_ec2_key_name }}"
  register: ec2_keys
  failed_when: false

- name: Verify AWS VPC exists
  tags:
    - 1_validation
  amazon.aws.ec2_vpc_net_info:
    profile: "{{ aws_profile }}"
    region: "{{ ocp_region }}"
    vpc_ids: "{{ aws_vpc_id }}"
  register: vpc_info
  failed_when: false

- name: Display VPC info
  tags:
    - 1_validation
  ansible.builtin.debug:
    msg: "VPC lookup result: {{ vpc_info }}"

- name: Display pre-deployment information
  tags:
    - 1_validation
  ansible.builtin.debug:
    msg: |
      ============================================================
      Hitachi VSP One SDS Block Deployment
      ============================================================
      
      Stack Configuration:
        Stack Name: {{ sds_stack_name }}
        Region: {{ ocp_region }}
        Instance Type: {{ sds_instance_type }}
        Root Volume Size: {{ sds_root_volume_size }} GB
        Data Volume Size: {{ sds_data_volume_size }} GB
      
      Network Configuration:
        VPC ID: {{ aws_vpc_id }}
        Key Pair: {{ aws_ec2_key_name }}
      
      CloudFormation Template: {{ cf_template_path }}
      ============================================================

# ======================================================================
# Phase 2: Get Network Information
# ======================================================================
- name: Get available subnets in VPC
  tags:
    - 2_network
  amazon.aws.ec2_vpc_subnet_info:
    profile: "{{ aws_profile }}"
    region: "{{ ocp_region }}"
    filters:
      vpc-id: "{{ aws_vpc_id }}"
  register: vpc_subnets

- name: Display available subnets
  tags:
    - 2_network
  ansible.builtin.debug:
    msg: |
      Available Subnets:
      {% for subnet in vpc_subnets.subnets %}
      - Subnet ID: {{ subnet.id }}
        CIDR: {{ subnet.cidr_block }}
        AZ: {{ subnet.availability_zone }}
        Available IPs: {{ subnet.available_ip_address_count }}
      {% endfor %}

- name: Select subnets for SDS Block (or use provided) - MUST be in same AZ
  tags:
    - 2_network
  block:
    - name: Debug available subnets with AZ info
      ansible.builtin.debug:
        msg: |
          Available subnets for AZ selection:
          {% for subnet in vpc_subnets.subnets %}
          - ID: {{ subnet.id }}, AZ: {{ subnet.availability_zone }}, CIDR: {{ subnet.cidr_block }}
          {% endfor %}

    - name: Select subnets from first AZ (ensures same AZ for CloudFormation)
      ansible.builtin.set_fact:
        # Get the AZ from first subnet
        sds_first_subnet_az: "{{ vpc_subnets.subnets[0].availability_zone }}"
        # Get all subnets in same AZ as first subnet
        sds_subnets_same_az: "{{ vpc_subnets.subnets | selectattr('availability_zone', 'equalto', vpc_subnets.subnets[0].availability_zone) | list }}"

    - name: Select control and data subnets
      ansible.builtin.set_fact:
        sds_control_subnet_id: "{{ sds_control_subnet_id | default(sds_subnets_same_az[0].id) }}"
        sds_data_subnet_id: "{{ sds_data_subnet_id | default(sds_subnets_same_az[1].id if sds_subnets_same_az | length > 1 else sds_subnets_same_az[0].id) }}"

    - name: Get AZ info for selected subnets
      ansible.builtin.set_fact:
        sds_control_az: "{{ (vpc_subnets.subnets | selectattr('id', 'equalto', sds_control_subnet_id) | first).availability_zone }}"
        sds_data_az: "{{ (vpc_subnets.subnets | selectattr('id', 'equalto', sds_data_subnet_id) | first).availability_zone }}"

    - name: Verify subnets are in same AZ
      ansible.builtin.assert:
        that:
          - sds_control_az == sds_data_az
        fail_msg: |
          âŒ ERROR: Control and Data subnets must be in the same Availability Zone!
          
          Control Subnet: {{ sds_control_subnet_id }} (AZ: {{ sds_control_az }})
          Data Subnet: {{ sds_data_subnet_id }} (AZ: {{ sds_data_az }})
          
          CloudFormation cannot attach network interfaces and volumes to an instance 
          if they are in different AZs. Please ensure both subnets are in the same AZ.
        success_msg: |
          âœ… Subnets verified - both in same AZ: {{ sds_control_az }}
          Control Subnet: {{ sds_control_subnet_id }}
          Data Subnet: {{ sds_data_subnet_id }}

- name: Get subnet CIDR blocks
  tags:
    - 2_network
  amazon.aws.ec2_vpc_subnet_info:
    profile: "{{ aws_profile }}"
    region: "{{ ocp_region }}"
    subnet_ids:
      - "{{ sds_control_subnet_id }}"
      - "{{ sds_data_subnet_id }}"
  register: selected_subnets

- name: Set subnet CIDR blocks
  tags:
    - 2_network
  ansible.builtin.set_fact:
    sds_control_subnet_cidr: "{{ selected_subnets.subnets[0].cidr_block }}"
    sds_data_subnet_cidr: "{{ selected_subnets.subnets[0].cidr_block if selected_subnets.subnets | length == 1 else selected_subnets.subnets[1].cidr_block }}"

# ======================================================================
# Phase 3: Get SDS Block AMI
# ======================================================================
- name: Search for Hitachi SDS Block AMI
  tags:
    - 3_ami
  amazon.aws.ec2_ami_info:
    profile: "{{ aws_profile }}"
    region: "{{ ocp_region }}"
    filters:
      name: "Hitachi-VSP-One-SDS-*"
      state: available
  register: sds_amis
  failed_when: false

- name: Set SDS Block AMI ID (from Hitachi marketplace or use default)
  tags:
    - 3_ami
  ansible.builtin.set_fact:
    sds_ami_id: "{{ (sds_amis.images | sort(attribute='creation_date', reverse=true) | first).image_id if sds_amis.images else sds_ami_id_override | default('ami-07d9228dc6ef5347a') }}"
    sds_ami_name: "{{ (sds_amis.images | sort(attribute='creation_date', reverse=true) | first).name if sds_amis.images else 'Amazon Linux 2 x86_64' }}"

- name: Display selected AMI
  tags:
    - 3_ami
  ansible.builtin.debug:
    msg: |
      Selected AMI:
        ID: {{ sds_ami_id }}
        Name: {{ sds_ami_name }}
        Note: Using default if Hitachi marketplace AMI not found

# ======================================================================
# Phase 4: Generate Secure SDS Block Password
# ======================================================================
- name: Generate secure password for SDS Block admin
  tags:
    - 4_security
  ansible.builtin.set_fact:
    sds_admin_password: "{{ lookup('password', '/dev/null chars=ascii_letters,digits,punctuation length=16') }}"
  when: sds_admin_password is not defined

- name: Save SDS Block credentials
  tags:
    - 4_security
  ansible.builtin.copy:
    content: |
      # Hitachi SDS Block Credentials
      # Generated: {{ now(utc=true).isoformat() }}
      # Stack: {{ sds_stack_name }}
      
      SDS_ADMIN_PASSWORD="{{ sds_admin_password }}"
      
      # Store this securely in AWS Secrets Manager or HashiCorp Vault
      # Do not commit to version control
    dest: "{{ ocpfolder }}/sds-block-credentials.env"
    mode: '0600'
  register: creds_file

- name: Display credentials file location
  tags:
    - 4_security
  ansible.builtin.debug:
    msg: |
      âš ï¸  SDS Block credentials saved to:
      {{ creds_file.dest }}
      
      âš ï¸  IMPORTANT: This file contains sensitive information
      âš ï¸  Store securely and do not commit to version control

# ======================================================================
# Phase 5: Create CloudFormation Stack
# ======================================================================
- name: Check if CloudFormation stack already exists
  tags:
    - 5_cloudformation
  amazon.aws.cloudformation_info:
    stack_name: "{{ sds_stack_name }}"
    region: "{{ ocp_region }}"
    profile: "{{ aws_profile }}"
  register: cf_stack_info
  ignore_errors: true

- name: Debug CloudFormation response
  tags:
    - 5_cloudformation
  ansible.builtin.debug:
    var: cf_stack_info
    verbosity: 2

- name: Check stack status
  tags:
    - 5_cloudformation
  block:
    - name: Initialize stack status
      ansible.builtin.set_fact:
        stack_exists: false
        stack_status: "NONE"
    
    - name: Check if stack exists in CloudFormation response
      ansible.builtin.set_fact:
        stack_exists: "{{ cf_stack_info.cloudformation is defined and sds_stack_name in cf_stack_info.cloudformation }}"
    
    - name: Extract stack status from list format
      ansible.builtin.set_fact:
        stack_status: "{{ cf_stack_info.cloudformation[sds_stack_name][0].stack_status }}"
      when:
        - stack_exists | bool
        - cf_stack_info.cloudformation[sds_stack_name] is iterable
        - cf_stack_info.cloudformation[sds_stack_name] | length > 0
      ignore_errors: true
    
    - name: Extract stack status from dict format
      ansible.builtin.set_fact:
        stack_status: "{{ cf_stack_info.cloudformation[sds_stack_name].stack_status }}"
      when:
        - stack_exists | bool
        - cf_stack_info.cloudformation[sds_stack_name] is mapping
      ignore_errors: true
    
    - name: Display stack status
      ansible.builtin.debug:
        msg: "Stack {{ sds_stack_name }} status: {{ stack_status }}"

- name: Delete failed CloudFormation stack if in ROLLBACK_COMPLETE state
  tags:
    - 5_cloudformation
  block:
    - name: Debug stack status before deletion
      ansible.builtin.debug:
        msg: |
          Stack exists: {{ stack_exists }}
          Stack status: {{ stack_status }}
          Should delete: {{ (stack_exists | bool) and (stack_status == 'ROLLBACK_COMPLETE') }}

    - name: Delete failed stack
      amazon.aws.cloudformation:
        stack_name: "{{ sds_stack_name }}"
        state: absent
        region: "{{ ocp_region }}"
        profile: "{{ aws_profile }}"
      when: 
        - stack_exists | bool
        - stack_status == 'ROLLBACK_COMPLETE'
      register: delete_stack_result

    - name: Wait for failed stack to be deleted
      amazon.aws.cloudformation_info:
        stack_name: "{{ sds_stack_name }}"
        region: "{{ ocp_region }}"
        profile: "{{ aws_profile }}"
      register: deleted_stack_check
      until: deleted_stack_check.cloudformation is not defined or sds_stack_name not in deleted_stack_check.cloudformation or deleted_stack_check.cloudformation[sds_stack_name] | length == 0
      retries: 30
      delay: 10
      when: delete_stack_result.changed
      failed_when: false

- name: Create or update SDS Block CloudFormation stack
  tags:
    - 5_cloudformation
  amazon.aws.cloudformation:
    stack_name: "{{ sds_stack_name }}"
    state: present
    region: "{{ ocp_region }}"
    profile: "{{ aws_profile }}"
    template_body: "{{ lookup('file', cf_template_path) }}"
    template_parameters:
      KeyName: "{{ aws_ec2_key_name }}"
      InstanceType: "{{ sds_instance_type }}"
      VpcId: "{{ aws_vpc_id }}"
      ControlSubnetId: "{{ sds_control_subnet_id }}"
      DataSubnetId: "{{ sds_data_subnet_id }}"
      ControlSubnetCidrBlock: "{{ sds_control_subnet_cidr }}"
      DataSubnetCidrBlock: "{{ sds_data_subnet_cidr }}"
      AvailabilityZone: "{{ sds_control_az }}"
      SDSBlockImageId: "{{ sds_ami_id }}"
      SDSBlockRootVolumeSize: "{{ sds_root_volume_size }}"
      SDSBlockDataVolumeSize: "{{ sds_data_volume_size }}"
      SDSBlockAdminPassword: "{{ sds_admin_password }}"
      Environment: "{{ environment_tag | default('development') }}"
      Owner: "{{ ansible_user | default(ansible_env.USER | default('automation')) }}"
    create_timeout: 600
    tags:
      Name: "{{ sds_stack_name }}"
      CreatedBy: Ansible
      ManagedBy: openshift-storage-scale
  register: cf_stack_result
  timeout: 1200

- name: Display CloudFormation stack creation result
  tags:
    - 5_cloudformation
  ansible.builtin.debug:
    msg: |
      CloudFormation stack operation completed:
      Stack Name: {{ sds_stack_name }}
      Stack Status: {{ cf_stack_result.stack_resources[0].status if cf_stack_result.stack_resources is defined else 'Unknown' }}
      Timestamp: {{ cf_stack_result.stack_resources[0].last_updated_time if cf_stack_result.stack_resources is defined else 'Unknown' }}

# ======================================================================
# Phase 6: Wait for Stack Completion
# ======================================================================
- name: Wait for CloudFormation stack to complete
  tags:
    - 6_wait
  block:
    - name: Check CloudFormation stack status repeatedly
      amazon.aws.cloudformation_info:
        stack_name: "{{ sds_stack_name }}"
        region: "{{ ocp_region }}"
        profile: "{{ aws_profile }}"
      register: cf_stack_status_check
      until: |
        (cf_stack_status_check.cloudformation[sds_stack_name] is iterable and
         cf_stack_status_check.cloudformation[sds_stack_name] | length > 0 and
         cf_stack_status_check.cloudformation[sds_stack_name][0].stack_status in ['CREATE_COMPLETE', 'UPDATE_COMPLETE']) or
        (cf_stack_status_check.cloudformation[sds_stack_name] is mapping and
         cf_stack_status_check.cloudformation[sds_stack_name].stack_status is defined and
         cf_stack_status_check.cloudformation[sds_stack_name].stack_status in ['CREATE_COMPLETE', 'UPDATE_COMPLETE'])
      retries: 120
      delay: 10
    
    - name: Extract final stack status
      ansible.builtin.set_fact:
        cf_final_stack_status: "{{ cf_stack_status_check.cloudformation[sds_stack_name][0].stack_status 
                                    if cf_stack_status_check.cloudformation[sds_stack_name] is iterable and cf_stack_status_check.cloudformation[sds_stack_name] | length > 0
                                    else cf_stack_status_check.cloudformation[sds_stack_name].stack_status }}"
    
    - name: Display final stack status
      ansible.builtin.debug:
        msg: "CloudFormation stack completed with status: {{ cf_final_stack_status }}"
    
    - name: Extract CloudFormation outputs
      ansible.builtin.set_fact:
        sds_outputs: "{{ cf_stack_status_check.cloudformation[sds_stack_name][0].stack_outputs | items2dict(key_name='output_key', value_name='output_value')
                          if cf_stack_status_check.cloudformation[sds_stack_name] is iterable and cf_stack_status_check.cloudformation[sds_stack_name] | length > 0
                          else cf_stack_status_check.cloudformation[sds_stack_name].stack_outputs | items2dict(key_name='output_key', value_name='output_value') }}"

# ======================================================================
# Phase 7: Retrieve SDS Block Access Information
# ======================================================================
- name: Get EC2 instance details
  tags:
    - 7_info
  amazon.aws.ec2_instance_info:
    region: "{{ ocp_region }}"
    profile: "{{ aws_profile }}"
    filters:
      "tag:Name": "hitachi-sds-block"
      instance-state-name: running
  register: sds_instances

- name: Wait for SDS Block instance to boot and initialize
  tags:
    - 7_info
  ansible.builtin.wait_for:
    host: "{{ sds_outputs.SDSBlockManagementEIP }}"
    port: 8443
    delay: 30
    timeout: 600
    state: started
  register: sds_boot_wait

- name: Display SDS Block Access Information
  tags:
    - 7_info
  ansible.builtin.debug:
    msg: |
      ============================================================
      Hitachi VSP One SDS Block Deployed Successfully!
      ============================================================
      
      Instance Information:
        Instance ID: {{ sds_outputs.SDSBlockInstanceId }}
        Instance Type: {{ sds_instance_type }}
        Region: {{ ocp_region }}
        Status: Running
      
      Network Configuration:
        Management IP (Private): {{ sds_outputs.SDSBlockManagementIP }}
        Management IP (Public/EIP): {{ sds_outputs.SDSBlockManagementEIP }}
        Data IP: {{ sds_outputs.SDSBlockDataIP }}
        Management SG: {{ sds_outputs.ManagementSecurityGroupId }}
        Data SG: {{ sds_outputs.DataSecurityGroupId }}
      
      Access Information:
        Web Console: https://{{ sds_outputs.SDSBlockManagementEIP }}:8443
        Username: admin
        Password: *** (stored in {{ creds_file.dest }})
      
      Storage Configuration:
        Root Volume: {{ sds_root_volume_size }} GB
        Data Volume: {{ sds_data_volume_size }} GB
      
      CloudWatch Logs:
        Log Group: {{ sds_outputs.CloudWatchLogGroup }}
      
      ============================================================
      
      Next Steps:
      1. Access the SDS Block web console
      2. Configure storage pools
      3. Set up replication (if needed)
      4. Create iSCSI port groups
      5. Update OCP Hitachi secrets with this information
      6. Deploy HSPC operator to OCP
      
      ============================================================

# ======================================================================
# Phase 8: Save Configuration for OCP Integration
# ======================================================================
- name: Create SDS Block configuration for OCP
  tags:
    - 8_config
  ansible.builtin.copy:
    content: |
      # Hitachi SDS Block Configuration
      # Auto-generated: {{ now(utc=true).isoformat() }}
      # Stack: {{ sds_stack_name }}
      
      # Access Information
      SDS_MANAGEMENT_IP={{ sds_outputs.SDSBlockManagementIP }}
      SDS_MANAGEMENT_EIP={{ sds_outputs.SDSBlockManagementEIP }}
      SDS_DATA_IP={{ sds_outputs.SDSBlockDataIP }}
      SDS_MANAGEMENT_SG={{ sds_outputs.ManagementSecurityGroupId }}
      SDS_DATA_SG={{ sds_outputs.DataSecurityGroupId }}
      
      # Instance Information
      SDS_INSTANCE_ID={{ sds_outputs.SDSBlockInstanceId }}
      SDS_INSTANCE_TYPE={{ sds_instance_type }}
      SDS_REGION={{ ocp_region }}
      
      # CloudFormation Stack
      SDS_STACK_NAME={{ sds_stack_name }}
      SDS_STACK_ID={{ cf_stack_result.stack_id }}
      
      # Web Console
      SDS_CONSOLE_URL=https://{{ sds_outputs.SDSBlockManagementEIP }}:8443
      SDS_ADMIN_USERNAME=admin
      
      # iSCSI Configuration
      SDS_ISCSI_PORT=3260
      SDS_ISCSI_TARGET_IP={{ sds_outputs.SDSBlockDataIP }}
      
      # For OCP Kubernetes Secret
      HITACHI_SDS_MANAGEMENT_IP={{ sds_outputs.SDSBlockManagementIP }}
      HITACHI_SDS_PORT=8443
      HITACHI_SDS_USERNAME=admin
      
    dest: "{{ ocpfolder }}/sds-block-config.env"
    mode: '0644'
  register: config_file

- name: Display configuration file location
  tags:
    - 8_config
  ansible.builtin.debug:
    msg: |
      SDS Block configuration saved to:
      {{ config_file.dest }}
      
      Use this file to configure OCP Hitachi secrets:
      oc create secret generic hitachi-sds-secret \
        --from-env-file={{ config_file.dest }} \
        -n hitachi-system

